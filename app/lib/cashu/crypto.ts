import {
  type MintKeys,
  OutputData,
  type SerializedBlindedMessage,
} from '@cashu/cashu-ts';
import { blindMessage } from '@cashu/cashu-ts/crypto/client';
import {
  deriveBlindingFactor,
  deriveSecret,
} from '@cashu/cashu-ts/crypto/client/NUT09';
import { bytesToNumber } from '@cashu/cashu-ts/crypto/util';
import type { WeierstrassPoint } from '@noble/curves/abstract/weierstrass';
import { bytesToHex } from '@noble/hashes/utils';
import { P2PKSecretSchema, type P2PKSpendingConditionData } from './types';
import { splitAmount } from './utils';

/**
 * The blinded secret `B_` where `B_ = Y + rG`
 *
 * ```json
 *  {
 *    "amount": 100,
 *    "id": "00ffd48b8f5ecf80",
 *    "B_": "02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2"
 * }
 * ```
 *
 * - `amount` is the value for the requested `BlindedSignature`
 * - `B_` is the blinded secret message generated by Alice
 * - `id` is the requested keyset ID to get signatures from.
 * - This is also the keyset ID used for deterministic output data
 *
 * @see https://github.com/cashubtc/nuts/blob/main/00.md#blindedmessage
 * @source https://github.com/cashubtc/cashu-ts/blob/development/src/model/BlindedMessage.ts
 */
class BlindedMessage {
  /**
   * The value for the requested BlindSignature
   */
  amount: number;
  /**
   * The blinded secret message generated by Alice as an elliptic curve point
   */
  B_: WeierstrassPoint<bigint>;
  /**
   * The keyset ID from which a signature is expected
   */
  id: string;

  constructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {
    this.amount = amount;
    this.B_ = B_;
    this.id = id;
  }

  getSerializedBlindedMessage(): SerializedBlindedMessage {
    return {
      amount: this.amount,
      B_: this.B_.toHex(true),
      id: this.id,
    };
  }
}

/**
 * Creates output data for a deterministic P2PK swap
 *
 * The secret that gets blinded is a well-known P2PK secret with a deterministic nonce.
 *
 * The nonce is derived in the same way as the deterministic secret defined in NUT-13
 *
 * @see https://github.com/cashubtc/nuts/blob/main/13.md
 */
export const createDeterministicP2PKData = (
  amount: number,
  seed: Uint8Array,
  counter: number,
  keys: MintKeys,
  p2pk: P2PKSpendingConditionData,
  customSplit?: number[],
) => {
  const amounts = splitAmount(amount, keys.keys, customSplit);
  return amounts.map((a, i) =>
    createSingleDeterministicP2PKData(a, seed, counter + i, keys.id, p2pk),
  );
};

const createSingleDeterministicP2PKData = (
  amount: number,
  seed: Uint8Array,
  counter: number,
  keysetId: string,
  p2pkCondition: P2PKSpendingConditionData,
) => {
  const p2pkData = OutputData.createSingleP2PKData(
    {
      pubkey: p2pkCondition.data,
      ...p2pkCondition.conditions,
    },
    amount,
    keysetId,
  );

  const p2pkBytes = p2pkData.secret;
  const p2pkJson = JSON.parse(new TextDecoder().decode(p2pkBytes));
  const p2pk = P2PKSecretSchema.parse({
    kind: p2pkJson[0],
    ...p2pkJson[1],
  });

  const deterministicNonce = deriveSecret(seed, keysetId, counter);
  const deterministicR = bytesToNumber(
    deriveBlindingFactor(seed, keysetId, counter),
  );

  p2pk.nonce = bytesToHex(deterministicNonce);

  const deterministicP2PK = new TextEncoder().encode(JSON.stringify(p2pk));
  const { r, B_ } = blindMessage(deterministicP2PK, deterministicR);

  return new OutputData(
    new BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),
    r,
    deterministicP2PK,
  );
};
