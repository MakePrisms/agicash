alter table "wallet"."cashu_receive_quotes" drop constraint "cashu_receive_quotes_quote_id_key";

-- NOTE: this is only necessary if we merge https://github.com/MakePrisms/boardwalkcash/pull/583 and add this index to the cashu_receive_quotes table
drop index if exists "wallet"."cashu_receive_quotes_quote_id_key";

create table "wallet"."reusable_cashu_receive_quotes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "account_id" uuid not null,
    "currency" text,
    "locking_derivation_path" text not null,
    "payment_request" text not null,
    "quote_id" text not null,
    "expires_at" timestamp with time zone,
    "amount_paid" numeric not null default 0,
    "amount_issued" numeric not null default 0,
    "receive_quote_ids" uuid[] not null default '{}'::uuid[], -- TODO: do we need this?
    "amount" numeric
);


alter table "wallet"."reusable_cashu_receive_quotes" enable row level security;

alter table "wallet"."cashu_receive_quotes" add column "reusable_cashu_receive_quote_id" bigint;

CREATE INDEX cashu_receive_quotes_reusable_cashu_receive_quote_id_idx ON wallet.cashu_receive_quotes USING btree (reusable_cashu_receive_quote_id);

CREATE UNIQUE INDEX reusable_cashu_receive_quotes_payment_request_key ON wallet.reusable_cashu_receive_quotes USING btree (payment_request);

CREATE UNIQUE INDEX reusable_cashu_receive_quotes_pkey ON wallet.reusable_cashu_receive_quotes USING btree (id);

CREATE UNIQUE INDEX reusable_cashu_receive_quotes_quote_id_key ON wallet.reusable_cashu_receive_quotes USING btree (quote_id);

alter table "wallet"."reusable_cashu_receive_quotes" add constraint "reusable_cashu_receive_quotes_pkey" PRIMARY KEY using index "reusable_cashu_receive_quotes_pkey";

alter table "wallet"."cashu_receive_quotes" add constraint "cashu_receive_quotes_reusable_cashu_receive_quote_id_fkey" FOREIGN KEY (reusable_cashu_receive_quote_id) REFERENCES wallet.reusable_cashu_receive_quotes(id) not valid;

alter table "wallet"."cashu_receive_quotes" validate constraint "cashu_receive_quotes_reusable_cashu_receive_quote_id_fkey";

alter table "wallet"."reusable_cashu_receive_quotes" add constraint "reusable_cashu_receive_quotes_account_id_fkey" FOREIGN KEY (account_id) REFERENCES wallet.accounts(id) not valid;

alter table "wallet"."reusable_cashu_receive_quotes" validate constraint "reusable_cashu_receive_quotes_account_id_fkey";

alter table "wallet"."reusable_cashu_receive_quotes" add constraint "reusable_cashu_receive_quotes_payment_request_key" UNIQUE using index "reusable_cashu_receive_quotes_payment_request_key";

alter table "wallet"."reusable_cashu_receive_quotes" add constraint "reusable_cashu_receive_quotes_quote_id_key" UNIQUE using index "reusable_cashu_receive_quotes_quote_id_key";

alter table "wallet"."reusable_cashu_receive_quotes" add constraint "reusable_cashu_receive_quotes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES wallet.users(id) not valid;

alter table "wallet"."reusable_cashu_receive_quotes" validate constraint "reusable_cashu_receive_quotes_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION wallet.create_reusable_cashu_receive_quote(p_user_id uuid, p_account_id uuid, p_currency text, p_quote_id text, p_payment_request text, p_locking_derivation_path text, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_amount numeric DEFAULT NULL::numeric)
 RETURNS wallet.reusable_cashu_receive_quotes
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
    v_quote wallet.reusable_cashu_receive_quotes;
begin
    -- Create reusable quote record
    insert into wallet.reusable_cashu_receive_quotes (
        user_id,
        account_id,
        currency,
        amount,
        expires_at,
        locking_derivation_path,
        payment_request,
        quote_id
    ) values (
        p_user_id,
        p_account_id,
        p_currency,
        p_amount,
        p_expires_at,
        p_locking_derivation_path,
        p_payment_request,
        p_quote_id
    ) returning * into v_quote;

    return v_quote;
end;
$function$
;

-- update state type to include onchain
CREATE OR REPLACE FUNCTION wallet.create_cashu_receive_quote(p_user_id uuid, p_account_id uuid, p_amount numeric, p_currency text, p_unit text, p_quote_id text, p_payment_request text, p_expires_at timestamp with time zone, p_state text, p_locking_derivation_path text, p_receive_type text, p_encrypted_transaction_details text, p_description text DEFAULT NULL::text)
 RETURNS wallet.cashu_receive_quotes
 LANGUAGE plpgsql
AS $function$
declare
    v_transaction_id uuid;
    v_quote wallet.cashu_receive_quotes;
    v_transaction_type text;
    v_transaction_state text;
begin
    -- Map receive type to transaction type
    v_transaction_type := case p_receive_type
        when 'LIGHTNING' then 'CASHU_LIGHTNING'
        when 'TOKEN' then 'CASHU_TOKEN'
        when 'ONCHAIN' then 'CASHU_ONCHAIN'
        else null
    end;

    if v_transaction_type is null then
        raise exception 'Unsupported receive type: %', p_receive_type;
    end if;

    -- We create token receives as pending because the lightning payment on the sender
    -- side will be triggered by the receiver, so we know it should get paid.
    -- We create onchain as PENDING because they are already paid, we just need to complete the payment. TODO: if onchain receive quotes start in PAID state, then we can change this to PAID (see cashu-receive-quote-service.ts)
    -- For lightning, we create a draft transaction record because its not guaranteed that
    -- the invoice will ever be paid.
    v_transaction_state := case v_transaction_type
        when 'CASHU_TOKEN' then 'PENDING'
        when 'CASHU_ONCHAIN' then 'PENDING'
        else 'DRAFT'
    end;

    -- Create draft transaction record
    insert into wallet.transactions (
        user_id,
        account_id,
        direction,
        type,
        state,
        currency,
        encrypted_transaction_details
    ) values (
        p_user_id,
        p_account_id,
        'RECEIVE',
        v_transaction_type,
        v_transaction_state,
        p_currency,
        p_encrypted_transaction_details
    ) returning id into v_transaction_id;

    -- Create quote record
    insert into wallet.cashu_receive_quotes (
        user_id,
        account_id,
        amount,
        currency,
        unit,
        quote_id,
        payment_request,
        expires_at,
        description,
        state,
        locking_derivation_path,
        transaction_id,
        type
    ) values (
        p_user_id,
        p_account_id,
        p_amount,
        p_currency,
        p_unit,
        p_quote_id,
        p_payment_request,
        p_expires_at,
        p_description,
        p_state,
        p_locking_derivation_path,
        v_transaction_id,
        p_receive_type
    ) returning * into v_quote;

    return v_quote;
end;
$function$
;

grant delete on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant insert on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant references on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant select on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant trigger on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant truncate on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant update on table "wallet"."reusable_cashu_receive_quotes" to "anon";

grant delete on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant insert on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant references on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant select on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant trigger on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant truncate on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant update on table "wallet"."reusable_cashu_receive_quotes" to "authenticated";

grant delete on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant insert on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant references on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant select on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant trigger on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant truncate on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

grant update on table "wallet"."reusable_cashu_receive_quotes" to "service_role";

create policy "Enable CRUD for reusable_cashu_receive_quotes by user_id"
on "wallet"."reusable_cashu_receive_quotes"
as permissive
for all
to public
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));

-- enable realtime for reusable_cashu_receive_quotes
alter publication supabase_realtime add table wallet.reusable_cashu_receive_quotes;

